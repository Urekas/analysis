<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Tactical Board - v90 Dropbox Native & XML Fix</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- ğŸ”¥ Google API ë° GIS(Google Identity Services) ë¡œë“œ -->
    <script async defer src="https://apis.google.com/js/api.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client"></script>

    <style>
        @font-face { font-family: 'S-CoreDream-6Bold'; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/S-CoreDream-6Bold.woff') format('woff'); font-weight: normal; font-style: normal; }
        :root { --bg-color: #1a1a1a; --panel-bg: #2d2d2d; --accent: #e74c3c; --text: #eee; --sidebar-width: 280px; }
        body { margin: 0; padding: 0; background: var(--bg-color); color: var(--text); font-family: 'S-CoreDream-6Bold', sans-serif; overflow: hidden; display: flex; height: 100vh; user-select: none; -webkit-user-select: none; }

        /* ì¢Œì¸¡ ì‚¬ì´ë“œë°” */
        .sidebar { width: 80px; background: var(--panel-bg); display: flex; flex-direction: column; align-items: center; padding-top: 20px; box-shadow: 2px 0 10px rgba(0,0,0,0.5); z-index: 20; overflow-y: auto; flex-shrink: 0; }
        .sidebar::-webkit-scrollbar { width: 0; }
        .tool-btn { width: 50px; height: 50px; margin-bottom: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); background: transparent; color: #aaa; font-size: 1.4rem; cursor: pointer; transition: 0.2s; display: flex; justify-content: center; align-items: center; position: relative; flex-shrink: 0; }
        .tool-btn:hover { background: rgba(255,255,255,0.1); color: #fff; border-color: rgba(255,255,255,0.3); }
        .tool-btn.active { background: var(--accent); color: white; border-color: var(--accent); box-shadow: 0 0 15px rgba(231, 76, 60, 0.4); }
        .tool-btn::after { content: attr(data-shortcut); position: absolute; bottom: 2px; right: 4px; font-size: 0.6rem; opacity: 0.5; font-family: monospace; }
        .divider { width: 40px; height: 1px; background: #444; margin: 10px 0; flex-shrink: 0; }
        #btn-palm.active { background: #2ecc71; border-color: #2ecc71; color: white; }
        .finish-btn { color: #2ecc71; border-color: #2ecc71; display: none; } .finish-btn.show { display: flex; animation: bounce 0.5s; }
        
        /* ì¤‘ì•™ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ */
        .workspace { flex: 1; display: flex; flex-direction: column; background: #000; overflow: hidden; position: relative; }
        .media-container { flex: 1; position: relative; width: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; background: #000; }
        
        #youtube-player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; z-index: 1; pointer-events: none; }
        #local-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; z-index: 1; object-fit: contain; }
        .canvas-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }

        /* ìŠ¤í¬ëŸ¬ë²„ */
        .scrubber-area { height: 50px; width: 100%; background: #111; display: none; align-items: center; justify-content: center; padding: 0 20px; box-sizing: border-box; border-top: 1px solid #333; flex-shrink: 0; z-index: 10; }
        .scrubber-input { flex: 1; -webkit-appearance: none; height: 8px; background: #444; border-radius: 5px; cursor: pointer; margin: 0 15px; }
        .scrubber-input::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #e67e22; border-radius: 50%; cursor: transition: 0.1s; }
        .scrubber-input::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .time-display { font-family: monospace; color: #ccc; font-size: 0.9rem; min-width: 100px; text-align: center; }

        /* í•˜ë‹¨ íŒ¨ë„ */
        .bottom-panel { height: 70px; width: 100%; background: var(--panel-bg); display: flex; justify-content: center; align-items: center; border-top: 1px solid #444; z-index: 20; flex-shrink: 0; }
        .control-bar { display: flex; gap: 15px; align-items: center; }
        .color-dot { width: 28px; height: 28px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: transform 0.2s; position: relative; overflow: hidden; }
        .color-dot:hover { transform: scale(1.1); } .color-dot.selected { border-color: white; box-shadow: 0 0 0 2px var(--bg-color); transform: scale(1.1); }
        .c-white { background: #ffffff; } .c-red { background: #e63946; } .c-yellow { background: #ffbe0b; } .c-blue { background: #3a86ff; } .c-green { background: #2ecc71; } .c-black { background: #000000; border: 1px solid #555; }
        .slider-group { display: flex; align-items: center; gap: 8px; color: #aaa; font-size: 0.9rem; }
        input[type=range] { -webkit-appearance: none; width: 80px; height: 5px; background: #555; border-radius: 5px; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        .toggle-btn { width: 36px; height: 36px; border-radius: 8px; border: 1px solid #555; background: #333; color: #aaa; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 1rem; transition: 0.2s; }
        .toggle-btn:hover { color: white; background: #444; } .toggle-btn.active { background: #3498db; color: white; border-color: #3498db; }
        
        #status-msg { 
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.8); padding: 10px 25px; border-radius: 30px; 
            font-size: 1rem; color: #fff; border: 1px solid rgba(255,255,255,0.2); 
            z-index: 100; pointer-events: none; transition: opacity 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none;
        }
        .rec-blink { animation: blink 1s infinite; color: #e74c3c; margin-right: 8px; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        #guide-msg { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(231, 76, 60, 0.9); color: white; padding: 10px 25px; border-radius: 30px; font-size: 1rem; font-weight: bold; pointer-events: none; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); animation: fadeIn 0.3s; z-index: 100; }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        .file-input { display: none; }
        
        /* ìš°ì¸¡ ì‚¬ì´ë“œë°” (ë°ì´í„° ëª©ë¡) */
        .scene-sidebar { width: var(--sidebar-width); background: #222; border-left: 1px solid #444; display: flex; flex-direction: column; padding: 0; box-shadow: -2px 0 10px rgba(0,0,0,0.5); z-index: 30; transition: width 0.3s ease; overflow: hidden; flex-shrink: 0; }
        .scene-sidebar.closed { width: 0; padding: 0; border: none; }
        .sidebar-toggle-area { position: absolute; right: 0; top: 50%; transform: translateY(-50%); z-index: 40; }
        .scene-toggle-btn { width: 25px; height: 50px; background: #222; border: 1px solid #444; border-right: none; border-radius: 10px 0 0 10px; color: #aaa; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 0.8rem; box-shadow: -2px 0 5px rgba(0,0,0,0.3); }
        .scene-toggle-btn:hover { background: #333; color: white; }
        .sidebar-tabs { display: flex; border-bottom: 1px solid #444; background: #2d2d2d; min-width: 100%; flex-shrink: 0; }
        .tab-btn { flex: 1; padding: 15px 0; background: none; border: none; color: #888; cursor: pointer; font-size: 0.9rem; font-family: 'S-CoreDream-6Bold'; transition: 0.2s; }
        .tab-btn:hover { color: #ccc; }
        .tab-btn.active { color: var(--accent); border-bottom: 3px solid var(--accent); background: #333; }
        .tab-content { flex: 1; overflow-y: auto; display: none; padding: 15px; flex-direction: column; gap: 10px; min-width: 100%; box-sizing: border-box; }
        .tab-content.active { display: flex; }
        
        /* ì¼ë°˜ ì•„ì´í…œ ìŠ¤íƒ€ì¼ */
        .scene-item { background: #333; padding: 12px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; transition: 0.2s; }
        .scene-item:hover { background: #444; border-color: #666; }
        .scene-info { display: flex; flex-direction: column; gap: 4px; overflow: hidden; flex: 1; cursor: pointer; padding: 0 5px; }
        .scene-title { color: #fff; font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: bold; }
        .scene-time { color: var(--accent); font-size: 0.8rem; font-family: monospace; }
        .scene-del-btn { color: #888; background: none; border: none; cursor: pointer; padding: 5px; flex-shrink: 0; }
        .scene-del-btn:hover { color: #e74c3c; }
        
        /* ğŸ”¥ ë°ì´í„° ê·¸ë£¹í™” ìŠ¤íƒ€ì¼ (XML/CSV) */
        .data-group { margin-bottom: 8px; display: flex; flex-direction: column; }
        .data-group-header { background: #3a3a3a; padding: 10px 12px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px; font-size: 0.95rem; font-weight: bold; color: #fff; border: 1px solid #444; transition: background 0.2s; user-select: none; }
        .data-group-header:hover { background: #4a4a4a; border-color: #555; }
        .group-toggle-icon { font-size: 0.8rem; color: #aaa; width: 14px; text-align: center; transition: transform 0.2s; }
        .group-count { background: var(--accent); color: #fff; font-size: 0.75rem; padding: 2px 8px; border-radius: 12px; margin-left: auto; font-family: monospace; }
        .data-group-content { display: flex; flex-direction: column; gap: 5px; padding-top: 5px; overflow: hidden; }
        
        .data-item { background: #2a2a2a; padding: 10px 12px; border-radius: 0 6px 6px 0; display: flex; justify-content: space-between; align-items: center; border-left: 3px solid #555; cursor: pointer; transition: 0.2s; margin-left: 10px; }
        .data-item:hover { background: #383838; border-left-color: var(--accent); }
        .data-label { font-size: 0.85rem; color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 3px; }

        /* ì»¨íŠ¸ë¡¤ ë°•ìŠ¤ */
        .control-box { background: #333; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #444; display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; }
        .sync-control { display: flex; justify-content: space-between; align-items: center; }
        .sync-btn { background: #444; border: none; color: #eee; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; }
        .sync-btn:hover { background: #555; }
        .sync-display { color: var(--accent); font-family: monospace; font-size: 0.9rem; }
        .unit-select { width: 100%; background: #444; color: #eee; border: 1px solid #555; padding: 5px; border-radius: 5px; font-size: 0.85rem; cursor: pointer; }

        .top-menu { position: absolute; top: 20px; right: 20px; display: flex; gap: 15px; z-index: 100; }
        .top-btn { background: rgba(0,0,0,0.6); color: #ccc; border: 1px solid #555; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; font-family: 'S-CoreDream-6Bold'; transition: 0.2s; display: flex; align-items: center; gap: 8px; }
        .top-btn:hover { background: #e74c3c; color: white; border-color: #e74c3c; }
        
        /* ëª¨ë‹¬ */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-box { background: #2d2d2d; padding: 25px; border-radius: 15px; width: 90%; max-width: 550px; border: 1px solid #444; box-shadow: 0 10px 40px rgba(0,0,0,0.8); position: relative; max-height: 85vh; overflow-y: auto;}
        .close-btn { position: absolute; top: 15px; right: 20px; background: none; border: none; color: #aaa; font-size: 1.8rem; cursor: pointer; transition: 0.2s; }
        .close-btn:hover { color: white; }
        .modal-header { font-size: 1.5rem; margin-bottom: 15px; border-bottom: none; padding-bottom: 0; color: var(--accent); }
        
        .modal-tabs { display: flex; border-bottom: 1px solid #444; margin-bottom: 15px; gap: 10px; }
        .m-tab { padding: 8px 15px; cursor: pointer; color: #888; border-bottom: 2px solid transparent; font-size: 1rem; transition: 0.2s; }
        .m-tab:hover { color: #ccc; }
        .m-tab.active { color: var(--accent); border-bottom: 2px solid var(--accent); }
        .m-content { display: none; font-size: 0.95rem; line-height: 1.6; color: #ddd; }
        .m-content.active { display: block; }

        .shortcut-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #333; }
        .shortcut-row:last-child { border-bottom: none; }
        .shortcut-input { background: #111; color: var(--accent); border: 1px solid #555; padding: 5px 10px; border-radius: 5px; width: 100px; text-align: center; cursor: pointer; font-family: 'S-CoreDream-6Bold'; font-size: 0.9rem; transition: 0.2s; }
        .shortcut-input:focus { border-color: var(--accent); outline: none; background: #000; box-shadow: 0 0 8px rgba(231, 76, 60, 0.4); }

        /* ëª¨ë°”ì¼ ë·°ì–´ ëª¨ë“œ */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            .sidebar, .bottom-panel, .sidebar-toggle-area { display: none !important; }
            .workspace { flex: none; height: 45vh; width: 100%; border-bottom: 2px solid var(--accent); }
            .scene-sidebar { width: 100%; flex: 1; border-left: none; height: 55vh; }
            .scene-sidebar.closed { width: 100%; height: auto; } 
            .top-menu { top: 10px; right: 10px; gap: 5px; }
            .top-btn { padding: 5px 10px; font-size: 0.8rem; }
            #status-msg { top: 10px; font-size: 0.8rem; padding: 5px 15px; width: 60%; text-align: center; }
            .scrubber-area { height: 40px; padding: 0 10px; }
            .time-display { font-size: 0.8rem; min-width: 80px; }
            .scene-item, .data-item { padding: 12px; margin-bottom: 6px; }
            .scene-title { font-size: 1rem; }
            .data-label { font-size: 0.85rem; }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <!-- ğŸ”¥ êµ¬ê¸€ ë“œë¼ì´ë¸Œ ì—°ë™ ë²„íŠ¼ -->
        <button class="tool-btn" id="btn-gdrive" style="background:#f39c12; color:white; border:none;" onclick="authAndPickDriveFile()" title="êµ¬ê¸€ ë“œë¼ì´ë¸Œ ì—´ê¸° (OAuth)"><i class="fa-brands fa-google-drive"></i></button>
        <div class="divider"></div>

        <label for="imgInput" class="tool-btn" style="background:#2ecc71; color:white; border:none;" title="ì‚¬ì§„ ì—´ê¸°"><i class="fa-solid fa-image"></i></label>
        <input type="file" id="imgInput" class="file-input" accept="image/*">
        <label for="videoInput" class="tool-btn" style="background:#3498db; color:white; border:none;" title="íŒŒì¼ ì˜ìƒ ì—´ê¸° (PC/Macìš©)"><i class="fa-solid fa-file-video"></i></label>
        <input type="file" id="videoInput" class="file-input" accept="video/*">
        <label for="dataInput" class="tool-btn" style="background:#9b59b6; color:white; border:none;" title="ë°ì´í„° ì—´ê¸° (XML/CSV)"><i class="fa-solid fa-file-lines"></i></label>
        <input type="file" id="dataInput" class="file-input" accept=".xml,.csv">
        <button class="tool-btn" style="background:#e63946; color:white; border:none;" onclick="loadYoutubePrompt()" title="ìœ íŠœë¸Œ ì£¼ì†Œ ì—´ê¸°"><i class="fa-brands fa-youtube"></i></button>
        <div class="divider"></div>
        <button class="tool-btn" id="btn-rewind" onclick="videoControl('rewind')" title="-5ì´ˆ ì´ë™"><i class="fa-solid fa-backward-step"></i></button>
        <button class="tool-btn" id="btn-play" onclick="videoControl('toggle')" title="ì¬ìƒ/ì •ì§€"><i class="fa-solid fa-play"></i></button>
        <button class="tool-btn" id="btn-forward" onclick="videoControl('forward')" title="+5ì´ˆ ì´ë™"><i class="fa-solid fa-forward-step"></i></button>
        <div class="divider"></div>
        <button class="tool-btn" id="btn-palm" onclick="togglePalm()" title="í„°ì¹˜ ë°©ì§€ (íœ ì „ìš©)"><i class="fa-solid fa-hand-pointer"></i></button>
        <div class="divider"></div>
        <button class="tool-btn active" id="btn-select" onclick="setMode('select')" title="ì„ íƒ ëª¨ë“œ"><i class="fa-solid fa-arrow-pointer"></i></button>
        <button class="tool-btn" id="btn-drawPlayerTag" onclick="setMode('drawPlayerTag')" title="ìŠ¤ë§ˆíŠ¸ ì„ ìˆ˜ íƒœê·¸"><i class="fa-solid fa-tag"></i></button>
        <button class="tool-btn" id="btn-drawPen" onclick="setMode('drawPen')" title="ììœ  íœ"><i class="fa-solid fa-pen"></i></button>
        <button class="tool-btn" id="btn-addText" onclick="addText()" title="í…ìŠ¤íŠ¸ ì¶”ê°€"><i class="fa-solid fa-font"></i></button>
        <button class="tool-btn" id="btn-drawSpot" onclick="setMode('drawSpot')" title="í•˜ì´ë¼ì´íŠ¸"><i class="fa-regular fa-circle"></i></button>
        <button class="tool-btn" id="btn-drawPolyline" onclick="setMode('drawPolyline')" title="ë‹¤ì¤‘ ì„ "><i class="fa-solid fa-share-nodes"></i></button>
        <button class="tool-btn" id="btn-drawArrow" onclick="setMode('drawArrow')" title="í™”ì‚´í‘œ"><i class="fa-solid fa-arrow-right-long"></i></button>
        <button class="tool-btn" id="btn-drawCurve" onclick="setMode('drawCurve')" title="ê³¡ì„ "><i class="fa-solid fa-arrow-turn-up"></i></button>
        <button class="tool-btn" id="btn-drawPolygon" onclick="setMode('drawPolygon')" title="ë‹¤ê°í˜•"><i class="fa-solid fa-draw-polygon"></i></button>
        <button class="tool-btn finish-btn" id="btn-finish" onclick="completeDrawing()"><i class="fa-solid fa-check"></i></button>
        <div class="divider"></div>
        <button class="tool-btn" style="color:#f1c40f;" onclick="saveScene()" title="í˜„ì¬ ì¥ë©´ ì €ì¥ (ìš°ì¸¡ ëª©ë¡ì— ì¶”ê°€)"><i class="fa-solid fa-floppy-disk"></i></button>
        <button class="tool-btn" id="btn-record" style="color:#e67e22;" onclick="startCleanRecording()" title="ì‹œí€€ìŠ¤ ê³ í™”ì§ˆ ì˜ìƒ ì¶”ì¶œ"><i class="fa-solid fa-clapperboard"></i></button>
        <div class="divider"></div>
        <button class="tool-btn" id="btn-delete" style="color:#e74c3c;" onclick="deleteObject()" title="ì„ íƒí•œ ê·¸ë¦¼ ì§€ìš°ê¸°"><i class="fa-solid fa-trash"></i></button>
        <button class="tool-btn" style="color:#ff6b6b; border-color:#ff6b6b;" onclick="clearAll()" title="í™”ë©´ ê·¸ë¦¼ ëª¨ë‘ ì§€ìš°ê¸°"><i class="fa-solid fa-eraser"></i></button>
        <div class="divider"></div>
        <button class="tool-btn" style="color:#3498db;" onclick="downloadImage()" title="ë¶„ì„í™”ë©´ ì´ë¯¸ì§€ ì €ì¥"><i class="fa-solid fa-download"></i></button>
    </div>

    <div class="workspace">
        <div class="sidebar-toggle-area">
            <div class="scene-toggle-btn" onclick="toggleSceneSidebar()" title="ì‚¬ì´ë“œë°” ì ‘ê¸°/í´ê¸°"><i class="fa-solid fa-chevron-right" id="sceneToggleIcon"></i></div>
        </div>
        <div class="top-menu">
            <button class="top-btn" onclick="toggleLang()"><i class="fa-solid fa-globe"></i> <span id="langText">KR | EN</span></button>
            <button class="top-btn" onclick="toggleHelp()"><i class="fa-solid fa-gear"></i> ê°€ì´ë“œ ë° ë‹¨ì¶•í‚¤</button>
        </div>
        <div id="status-msg">ë¯¸ë””ì–´ë¥¼ ë¶ˆëŸ¬ì™€ ì‹œì‘í•˜ì„¸ìš”.</div>
        <div id="guide-msg">ë”ë¸”í´ë¦­í•˜ì—¬ ë„í˜• ì™„ì„±</div>
        <div class="media-container" id="mediaContainer">
            <div id="youtube-player"></div>
            <video id="local-video" playsinline crossOrigin="anonymous"></video>
            <div class="canvas-wrapper"><canvas id="c"></canvas></div>
        </div>
        <div class="scrubber-area" id="videoScrubber">
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
            <input type="range" class="scrubber-input" id="timeSlider" min="0" max="100" value="0" step="0.1">
        </div>
        <div class="bottom-panel">
            <div class="control-bar">
                <div style="display:flex; gap:8px;">
                    <div class="color-dot c-white selected" onclick="setColor('#ffffff', this)"></div>
                    <div class="color-dot c-red" onclick="setColor('#e63946', this)"></div>
                    <div class="color-dot c-yellow" onclick="setColor('#ffbe0b', this)"></div>
                    <div class="color-dot c-blue" onclick="setColor('#3a86ff', this)"></div>
                    <div class="color-dot c-green" onclick="setColor('#2ecc71', this)"></div>
                    <div class="color-dot c-black" onclick="setColor('#000000', this)"></div>
                    <div id="customColorBtn1" class="color-dot" style="background:linear-gradient(135deg, #eee, #999);"><input type="color" oninput="setCustomColor(this.value, 1)" style="opacity:0; width:100%; height:100%; cursor:pointer;"></div>
                    <div id="customColorBtn2" class="color-dot" style="background:linear-gradient(135deg, #555, #000);"><input type="color" oninput="setCustomColor(this.value, 2)" style="opacity:0; width:100%; height:100%; cursor:pointer;"></div>
                </div>
                <div style="width:1px; height:30px; background:#555;"></div>
                <div id="dashBtn" class="toggle-btn" onclick="toggleDash()" title="ì ì„  ë³€ê²½"><i class="fa-solid fa-ellipsis"></i></div>
                <div id="nodeBtn" class="toggle-btn" onclick="toggleNodeMode()" title="ë…¸ë“œ ëª¨ì–‘ ë³€ê²½"><i class="fa-solid fa-circle-nodes"></i></div>
                <div style="width:1px; height:30px; background:#555;"></div>
                <div class="slider-group" data-key="size"><i class="fa-solid fa-up-right-and-down-left-from-center"></i><input type="range" id="sizeSlider" min="10" max="100" value="40"></div>
                <div class="slider-group" data-key="opacity"><i class="fa-solid fa-circle-half-stroke"></i><input type="range" id="opacitySlider" min="10" max="100" value="20"></div>
            </div>
        </div>
    </div>

    <div class="scene-sidebar" id="sceneSidebar">
        <div class="sidebar-tabs">
            <button class="tab-btn active" onclick="openTab('tab-scenes')"><i class="fa-solid fa-images"></i> ì €ì¥ëœ ì¥ë©´</button>
            <button class="tab-btn" onclick="openTab('tab-data')"><i class="fa-solid fa-database"></i> ë°ì´í„° ë¶„ì„</button>
        </div>
        <div id="tab-scenes" class="tab-content active"><div class="scene-list" id="sceneList"></div></div>
        <div id="tab-data" class="tab-content">
            <div class="control-box">
                <!-- ğŸ”¥ ê¸°ë³¸ ë‹¨ìœ„ë¥¼ 1ì´ˆ(sec)ë¡œ ê³ ì • -->
                <select id="timeUnit" class="unit-select" onchange="renderDataList()">
                    <option value="sec" selected>ë‹¨ìœ„: 1ì´ˆ (ê¸°ë³¸)</option>
                    <option value="ms">ë‹¨ìœ„: 1/1000ì´ˆ (ë°€ë¦¬ì´ˆ)</option>
                    <option value="cs">ë‹¨ìœ„: 1/100ì´ˆ (ë‹¤íŠ¸í”¼ì‰¬)</option>
                </select>
                <div class="sync-control">
                    <button class="sync-btn" onclick="adjustSync(-1)">-1s</button> <button class="sync-btn" onclick="adjustSync(-0.1)">-0.1</button>
                    <span class="sync-display" id="syncDisplay">Sync: 0.0s</span>
                    <button class="sync-btn" onclick="adjustSync(0.1)">+0.1</button> <button class="sync-btn" onclick="adjustSync(1)">+1s</button>
                </div>
            </div>
            <div class="scene-list" id="dataList"><div style="color:#777; text-align:center; margin-top:20px;">XML/CSV ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì„¸ìš”</div></div>
        </div>
    </div>

    <!-- ë„ì›€ë§ ëª¨ë‹¬ -->
    <div class="modal-overlay" id="helpModal" onclick="if(event.target === this) toggleHelp()">
        <div class="modal-box">
            <button class="close-btn" onclick="toggleHelp()">&times;</button>
            <div class="modal-header" id="modalTitle">ë„ì›€ë§ ë° ì„¤ì •</div>
            <div class="modal-tabs">
                <div class="m-tab active" id="tab-btn-guide" onclick="switchModalTab('guide')">ì‚¬ìš© ê°€ì´ë“œ</div>
                <div class="m-tab" id="tab-btn-shortcuts" onclick="switchModalTab('shortcuts')">ë‹¨ì¶•í‚¤ ì„¤ì •</div>
            </div>
            
            <div id="m-guide" class="m-content active">
                <h3 style="color:#f39c12; margin-top:0; font-size:1.1rem;">ğŸ”¥ [NEW] êµ¬ê¸€ ë“œë¼ì´ë¸Œ ì—°ë™ (OAuth)</h3>
                <p style="font-size:0.9rem; color:#ccc; margin-bottom:15px;">
                   ì¢Œì¸¡ ìƒë‹¨ êµ¬ê¸€ ë“œë¼ì´ë¸Œ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë‚´ í´ë¼ìš°ë“œ ì €ì¥ì†Œ í´ë”ê°€ ì—´ë¦¬ë©°, ì˜ìƒ(MP4)ê³¼ ë°ì´í„°(XML)ë¥¼ ë°”ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </p>

                <h3 style="color:#e74c3c; font-size:1.1rem;">1. ğŸ¥ ë¯¸ë””ì–´ ë° ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°</h3>
                <p style="font-size:0.9rem; color:#ccc; margin-bottom:15px;">
                   - ë“œë¡­ë°•ìŠ¤ ì—°ë™ ì‹œ ì£¼ì†Œì°½ì— <code>?video=ì˜ìƒURL&data=XMLURL</code> í˜•ì‹ìœ¼ë¡œ ìë™ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ê³µìœ ë§í¬ ëì„ dl=1ë¡œ ë³€ê²½)
                </p>
                
                <h3 style="color:#3498db; font-size:1.1rem;">2. âœï¸ ì „ìˆ  ë“œë¡œì‰ ë° íƒœê¹…</h3>
                <p style="font-size:0.9rem; color:#ccc; margin-bottom:15px;">
                   - <b>ìŠ¤ë§ˆíŠ¸ ì„ ìˆ˜ íƒœê·¸</b>: ì„ ìˆ˜ì˜ ë°œë°‘ì„ í´ë¦­í•˜ë©´ ì§€ì‹œì„ ê³¼ íƒœê·¸ê°€ ìë™ ìƒì„±ë©ë‹ˆë‹¤.
                </p>

                <h3 style="color:#f1c40f; font-size:1.1rem;">3. ğŸ¬ ê³ í™”ì§ˆ ì‹œí€€ìŠ¤ ì¶”ì¶œ</h3>
                <p style="font-size:0.9rem; color:#ccc; margin-bottom:15px;">
                    ì¥ë©´ì„ ì €ì¥(ğŸ’¾)í•˜ê³  í´ë˜í¼ë³´ë“œ(ğŸ¬) ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ê³ í™”ì§ˆ ë¶„ì„ ì˜ìƒì´ ìë™ ìƒì„±ë©ë‹ˆë‹¤.
                </p>
            </div>

            <div id="m-shortcuts" class="m-content">
                <p style="color:#aaa; font-size:0.85rem; margin-top:0; border-bottom:1px solid #444; padding-bottom:10px;">ë³€ê²½í•  í•­ëª©ì˜ ì…ë ¥ì¹¸ì„ í´ë¦­ í›„ ì›í•˜ëŠ” í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”. (ëŒ€ì†Œë¬¸ì êµ¬ë¶„)</p>
                <div id="shortcut-list" style="max-height: 40vh; overflow-y: auto; padding-right:10px;"></div>
                <button onclick="saveShortcuts()" style="margin-top:15px; padding:10px 20px; background:var(--accent); color:white; border:none; border-radius:5px; cursor:pointer; width:100%; font-family: 'S-CoreDream-6Bold'; font-size:1rem;">ë‹¨ì¶•í‚¤ ì €ì¥ ë° ì ìš©</button>
            </div>
        </div>
    </div>

    <!-- ê¸°ë³¸ ìœ íŠœë¸Œ API ë¡œë“œ ìŠ¤í¬ë¦½íŠ¸ -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // ==========================================
        // ğŸ”¥ êµ¬ê¸€ ë“œë¼ì´ë¸Œ OAuth 2.0 ë° Picker API ì„¤ì • ğŸ”¥
        // ==========================================
        const GOOGLE_CLIENT_ID = '564078182848-p1qluedvql9e9s4btodh7e74othqm2ip.apps.googleusercontent.com'; 
        const GOOGLE_API_KEY = 'AIzaSyAIYNBpjy-MYzSP2ETsojEX41-Wcgt2fp8';
        const GOOGLE_SHARED_FOLDER_ID = '1E8wSOQfwmFEh5RTxwD_wFjKSHkTyTZtX'; 
        const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/drive.readonly';
        
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let driveAccessToken = null;

        function gapiLoaded() {
            gapi.load('client:picker', initializeGapiClient);
        }
        async function initializeGapiClient() {
            if (GOOGLE_API_KEY === 'YOUR_API_KEY_HERE') return;
            await gapi.client.init({ apiKey: GOOGLE_API_KEY });
            gapiInited = true;
        }

        function gisLoaded() {
            if (GOOGLE_CLIENT_ID === 'YOUR_CLIENT_ID_HERE') return;
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_SCOPES,
                callback: (tokenResponse) => {
                    if (tokenResponse && tokenResponse.access_token) {
                        driveAccessToken = tokenResponse.access_token;
                        createPicker();
                    }
                },
            });
            gisInited = true;
        }

        function authAndPickDriveFile() {
            if (!gapiInited || !gisInited) { alert("êµ¬ê¸€ APIê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."); return; }
            if (driveAccessToken === null) { tokenClient.requestAccessToken({prompt: 'consent'}); } 
            else { tokenClient.requestAccessToken({prompt: ''}); }
        }

        function createPicker() {
            const view = new google.picker.DocsView(google.picker.ViewId.DOCS);
            view.setMimeTypes("video/mp4,video/webm,video/quicktime,video/*,text/xml,text/csv,text/plain,application/xml,application/vnd.google-apps.folder");
            view.setIncludeFolders(true); 
            
            if (GOOGLE_SHARED_FOLDER_ID && GOOGLE_SHARED_FOLDER_ID !== 'YOUR_SHARED_FOLDER_ID_HERE') {
                view.setParent(GOOGLE_SHARED_FOLDER_ID);
            }
            
            const picker = new google.picker.PickerBuilder()
                .addView(view)
                .enableFeature(google.picker.Feature.SUPPORT_DRIVES)
                .setOAuthToken(driveAccessToken)
                .setDeveloperKey(GOOGLE_API_KEY)
                .setCallback(pickerCallback)
                .build();
            picker.setVisible(true);
        }

        function pickerCallback(data) {
            if (data[google.picker.Response.ACTION] == google.picker.Action.PICKED) {
                const doc = data[google.picker.Response.DOCUMENTS][0];
                const fileId = doc[google.picker.Document.ID];
                const mimeType = doc[google.picker.Document.MIME_TYPE] || "";
                const fileName = doc[google.picker.Document.NAME] || "";

                showStatus(`êµ¬ê¸€ ë“œë¼ì´ë¸Œì—ì„œ '${fileName}' ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...`, true);

                if (mimeType.includes("video") || fileName.toLowerCase().match(/\.(mp4|webm|mov)$/)) {
                    const driveVideoUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&access_token=${driveAccessToken}`;
                    switchMode('local');
                    localVideo.src = driveVideoUrl;
                    localVideo.crossOrigin = "anonymous";
                    showStatus("êµ¬ê¸€ ë“œë¼ì´ë¸Œ ì˜ìƒ ë¡œë“œ ì™„ë£Œ!");
                    setTimeout(resizeCanvas, 500);
                } 
                else if (mimeType.includes("xml") || mimeType.includes("csv") || mimeType.includes("text") || fileName.match(/\.(xml|csv)$/i)) {
                    fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&supportsAllDrives=true`, {
                        headers: { Authorization: `Bearer ${driveAccessToken}` }
                    })
                    .then(response => {
                        if (!response.ok) throw new Error("ë„¤íŠ¸ì›Œí¬ ì‘ë‹µ ì—ëŸ¬: " + response.status);
                        return response.blob(); 
                    })
                    .then(blob => {
                        const r = new FileReader();
                        const isCsv = fileName.toLowerCase().endsWith('.csv') || mimeType.includes('csv');
                        
                        r.onload = function(d) {
                            if (isCsv) parseDartfishCSV(d.target.result);
                            else parseSportsCodeXML(d.target.result);
                            openTab('tab-data');
                            showStatus("êµ¬ê¸€ ë“œë¼ì´ë¸Œ ë°ì´í„° ì—°ë™ ì™„ë£Œ!");
                        };
                        
                        r.readAsText(blob, isCsv ? 'EUC-KR' : 'UTF-8');
                    })
                    .catch(err => {
                        console.error(err);
                        alert("êµ¬ê¸€ ë“œë¼ì´ë¸Œ ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ê³µìœ  ë“œë¼ì´ë¸Œ ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)");
                    });
                } else {
                    alert("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. (MP4, XML, CSVë§Œ ì§€ì›)");
                }
            }
        }

        window.onload = function() {
            gapiLoaded();
            gisLoaded();
        };

        // --- ê¸°ì¡´ URL íŒŒë¼ë¯¸í„° ìë™ íŒŒì‹± (ìœ íŠœë¸Œ & CORS Proxy ë° Dropbox Native ë³€ê²½ ì ìš©) ---
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const videoUrl = urlParams.get('video');
            const dataUrl = urlParams.get('data');
            
            if (videoUrl || dataUrl) showStatus("í´ë¼ìš°ë“œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...", true);

            if (videoUrl) {
                const ytMatch = videoUrl.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/\s]{11})/i);
                if (ytMatch && ytMatch[1]) {
                    const checkYt = setInterval(() => {
                        if (isYtReady && ytPlayer && ytPlayer.loadVideoById) {
                            clearInterval(checkYt);
                            switchMode('youtube');
                            ytPlayer.loadVideoById(ytMatch[1]);
                        }
                    }, 500);
                } else {
                    switchMode('local');
                    localVideo.src = videoUrl;
                    localVideo.crossOrigin = "anonymous";
                }
            }

            if (dataUrl) {
                async function loadExternalData() {
                    let fetchUrl = dataUrl;
                    
                    // ğŸ”¥ ìˆ˜ì •: ë“œë¡­ë°•ìŠ¤ ë§í¬ì¸ ê²½ìš° ì§í†µ ë‹¤ìš´ë¡œë“œ ì£¼ì†Œë¡œ ë³€ê²½í•˜ì—¬ CORSë¥¼ ì›ì²œ íšŒí”¼í•©ë‹ˆë‹¤.
                    if (fetchUrl.includes("dropbox.com")) {
                        fetchUrl = fetchUrl.replace(/(www\.)?dropbox\.com/, "dl.dropboxusercontent.com");
                        if (!fetchUrl.includes("dl=1")) fetchUrl = fetchUrl.replace("dl=0", "dl=1");
                    }

                    try {
                        let response;
                        try {
                            // 1. ì§ì ‘ í˜¸ì¶œ ì‹œë„ (ë“œë¡­ë°•ìŠ¤ëŠ” dl.dropboxusercontent.com ë•ë¶„ì— 99% ì—¬ê¸°ì„œ ì„±ê³µ)
                            response = await fetch(fetchUrl);
                            if (!response.ok) throw new Error("ì§ì ‘ í˜¸ì¶œ ì‹¤íŒ¨");
                        } catch (err) {
                            console.warn("ì§ì ‘ í˜¸ì¶œ ì‹¤íŒ¨, í”„ë¡ì‹œ ìš°íšŒ ì‹œë„...", err);
                            // 2. ë‹¤ë¥¸ ë§í¬ì´ê±°ë‚˜ ì§ì ‘ í˜¸ì¶œ ì‹¤íŒ¨ ì‹œ allorigins í”„ë¡ì‹œ ì‚¬ìš©
                            response = await fetch("https://api.allorigins.win/raw?url=" + encodeURIComponent(dataUrl));
                            if (!response.ok) throw new Error("í”„ë¡ì‹œ í˜¸ì¶œë„ ì‹¤íŒ¨");
                        }

                        const ct = response.headers.get("content-type") || "";
                        let textData = "";
                        let dataType = "xml";

                        if (dataUrl.toLowerCase().endsWith('.csv') || ct.includes('csv')) {
                            const buffer = await response.arrayBuffer();
                            const decoder = new TextDecoder('euc-kr');
                            textData = decoder.decode(buffer);
                            dataType = 'csv';
                        } else {
                            textData = await response.text();
                        }

                        if (dataType === 'csv') {
                            parseDartfishCSV(textData);
                        } else {
                            parseSportsCodeXML(textData);
                        }
                        
                        openTab('tab-data');
                        showStatus("ë°ì´í„° ìë™ ì—°ë™ ì™„ë£Œ!");

                    } catch (e) {
                        console.error("ë°ì´í„° íŒ¨ì¹˜ ì—ëŸ¬:", e);
                        alert("ë°ì´í„°(XML/CSV) ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨.\nì›ì¸: " + e.message + "\n\nğŸ’¡ ì¼ë°˜ì ì¸ ì›¹í•˜ë“œëŠ” ë³´ì•ˆ(CORS)ì— ë§‰í™ë‹ˆë‹¤. ë“œë¡­ë°•ìŠ¤ ê³µìœ  ë§í¬ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤.");
                    }
                }
                
                loadExternalData();
            }
        });

        // --- ë‹¨ì¶•í‚¤ ì‹œìŠ¤í…œ ---
        let shortcutConfig = {
            'select': { label: 'ì„ íƒ ëª¨ë“œ', key: 's' },
            'drawPlayerTag': { label: 'ì„ ìˆ˜ íƒœê·¸', key: 'T' },
            'drawPen': { label: 'ììœ  íœ', key: 'p' },
            'addText': { label: 'í…ìŠ¤íŠ¸ ì¶”ê°€', key: 't' },
            'drawSpot': { label: 'í•˜ì´ë¼ì´íŠ¸', key: 'h' },
            'drawPolyline': { label: 'ë‹¤ì¤‘ ì„ ', key: 'l' },
            'drawArrow': { label: 'í™”ì‚´í‘œ', key: 'a' },
            'drawCurve': { label: 'ê³¡ì„ ', key: 'c' },
            'drawPolygon': { label: 'ë‹¤ê°í˜•', key: 'g' },
            'deleteObj': { label: 'ì„ íƒ ì‚­ì œ', key: 'Delete' },
            'videoRewind': { label: 'ì˜ìƒ -5ì´ˆ', key: 'ArrowLeft' },
            'videoToggle': { label: 'ì¬ìƒ/ì •ì§€', key: ' ' },
            'videoForward': { label: 'ì˜ìƒ +5ì´ˆ', key: 'ArrowRight' }
        };

        function formatKeyDisplay(k) {
            if(k === ' ') return 'Space';
            if(k === 'ArrowLeft') return 'â†';
            if(k === 'ArrowRight') return 'â†’';
            if(k === 'ArrowUp') return 'â†‘';
            if(k === 'ArrowDown') return 'â†“';
            return k;
        }

        function initShortcuts() {
            const saved = localStorage.getItem('tacticalShortcuts');
            if (saved) {
                const parsed = JSON.parse(saved);
                for (const key in parsed) { if(shortcutConfig[key]) shortcutConfig[key].key = parsed[key].key; }
            }
            updateTooltipShortcuts();
        }

        function updateTooltipShortcuts() {
            const mapToElement = {
                'select': 'btn-select', 'drawPlayerTag': 'btn-drawPlayerTag', 'drawPen': 'btn-drawPen',
                'addText': 'btn-addText', 'drawSpot': 'btn-drawSpot', 'drawPolyline': 'btn-drawPolyline',
                'drawArrow': 'btn-drawArrow', 'drawCurve': 'btn-drawCurve', 'drawPolygon': 'btn-drawPolygon',
                'videoRewind': 'btn-rewind', 'videoToggle': 'btn-play', 'videoForward': 'btn-forward',
                'deleteObj': 'btn-delete'
            };
            for (const [action, btnId] of Object.entries(mapToElement)) {
                const btn = document.getElementById(btnId);
                if (btn) btn.setAttribute('data-shortcut', formatKeyDisplay(shortcutConfig[action].key));
            }
        }

        function renderShortcuts() {
            const container = document.getElementById('shortcut-list');
            container.innerHTML = '';
            for (const [id, config] of Object.entries(shortcutConfig)) {
                const row = document.createElement('div');
                row.className = 'shortcut-row';
                row.innerHTML = `<span>${config.label}</span> <input type="text" class="shortcut-input" id="sc-input-${id}" value="${formatKeyDisplay(config.key)}" readonly>`;
                container.appendChild(row);
                
                const input = row.querySelector(`#sc-input-${id}`);
                input.addEventListener('keydown', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (e.key === 'Escape' || e.key === 'Enter') { input.blur(); return; }
                    input.value = formatKeyDisplay(e.key);
                    shortcutConfig[id].key = e.key;
                });
            }
        }

        function saveShortcuts() {
            localStorage.setItem('tacticalShortcuts', JSON.stringify(shortcutConfig));
            updateTooltipShortcuts();
            showStatus("ë‹¨ì¶•í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
            toggleHelp();
        }

        function switchModalTab(tabId) {
            document.querySelectorAll('.m-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.m-content').forEach(c => c.classList.remove('active'));
            document.getElementById('tab-btn-' + tabId).classList.add('active');
            document.getElementById('m-' + tabId).classList.add('active');
            if (tabId === 'shortcuts') renderShortcuts();
        }

        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.isContentEditable || e.target.tagName === 'TEXTAREA') return;
            const pressedKey = e.key;
            if (pressedKey === ' ' || e.code === 'Space') e.preventDefault();

            let action = null;
            for (const [id, config] of Object.entries(shortcutConfig)) {
                if (config.key === pressedKey) { action = id; break; }
            }

            if (action) {
                switch(action) {
                    case 'select': setMode('select'); break; case 'drawPen': setMode('drawPen'); break; case 'drawPlayerTag': setMode('drawPlayerTag'); break;
                    case 'addText': addText(); break; case 'drawSpot': setMode('drawSpot'); break; case 'drawPolyline': setMode('drawPolyline'); break;
                    case 'drawArrow': setMode('drawArrow'); break; case 'drawCurve': setMode('drawCurve'); break; case 'drawPolygon': setMode('drawPolygon'); break;
                    case 'deleteObj': deleteObject(); break; case 'videoToggle': videoControl('toggle'); break;
                    case 'videoRewind': videoControl('rewind'); break; case 'videoForward': videoControl('forward'); break;
                }
            }
            if (e.key === 'Escape') { if(isDrawing) resetDrawing(); setMode('select'); }
        });

        initShortcuts();


        const statusMsg = document.getElementById('status-msg');
        let statusTimeout;
        
        function showStatus(msg, forceRec = false) {
            if(forceRec) {
                statusMsg.innerHTML = `<span class="rec-blink">â—</span>${msg}`;
                statusMsg.style.display = 'block';
                statusMsg.style.opacity = '1';
                clearTimeout(statusTimeout);
            } else {
                statusMsg.innerText = msg;
                statusMsg.style.display = 'block';
                statusMsg.style.opacity = '1';
                clearTimeout(statusTimeout); 
                statusTimeout = setTimeout(() => { statusMsg.style.opacity = '0'; setTimeout(()=>statusMsg.style.display='none', 300); }, 2000);
            }
        }

        let eventList = []; let timeOffset = 0.0;
        
        // ğŸ”¥ ìˆ˜ì •: XML íŒŒì‹± ì—ëŸ¬ ê°ì§€ ê¸°ëŠ¥ ì™„í™” (ë‹¨ìˆœ ì—ëŸ¬ë¼ë„ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì§„í–‰)
        function parseSportsCodeXML(text) {
            const parser = new DOMParser(); 
            const xmlDoc = parser.parseFromString(text, "text/xml");
            
            const parseError = xmlDoc.getElementsByTagName("parsererror");
            const instances = xmlDoc.getElementsByTagName("instance"); 
            
            // XMLì— ìì˜í•œ ë¬¸ë²• ì—ëŸ¬ê°€ ìˆë”ë¼ë„ <instance>ê°€ ì •ìƒì ìœ¼ë¡œ ì¡´ì¬í•˜ë©´ ê·¸ëŒ€ë¡œ ì§„í–‰ì‹œí‚µë‹ˆë‹¤.
            if(parseError.length > 0 && instances.length === 0) {
                alert("XML íŒŒì¼ í˜•ì‹ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì¸ì‹í•  ìˆ˜ ì—†ëŠ” í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.");
                return;
            }

            eventList = [];
            
            if (instances.length === 0) {
                if (text.trim().toLowerCase().startsWith("<!doctype html") || text.trim().toLowerCase().startsWith("<html")) {
                    alert("ì˜¤ë¥˜: ë°ì´í„° ëŒ€ì‹  ì›¹í˜ì´ì§€(HTML)ê°€ ë°˜í™˜ë˜ì—ˆìŠµë‹ˆë‹¤. ê³µìœ  ë§í¬ê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
                } else {
                    alert("ë°ì´í„° ì—†ìŒ: XML íŒŒì¼ ì•ˆì— ì „ìˆ  ë°ì´í„°(<instance>)ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ êµ¬ì¡°ê°€ ë‹¤ë¦…ë‹ˆë‹¤.");
                }
                return;
            }

            for (let i = 0; i < instances.length; i++) {
                const inst = instances[i];
                const start = parseFloat(inst.getElementsByTagName("start")[0]?.textContent || 0);
                const code = inst.getElementsByTagName("code")[0]?.textContent || "Event";
                let labelText = ""; const labels = inst.getElementsByTagName("label");
                if(labels.length > 0) { const txt = labels[0].getElementsByTagName("text")[0]; if(txt) labelText = txt.textContent; }
                eventList.push({ start: start, code: code, label: labelText });
            }
            renderDataList();
        }

        function parseDartfishCSV(text) {
            const lines = text.replace(/\r\n/g, "\n").split("\n"); if (lines.length < 2) return;
            const headers = lines[0].split(",").map(h => h.trim());
            const idxName = headers.indexOf("ì´ë¦„"); const idxPos = headers.indexOf("ìœ„ì¹˜"); 
            const idxTeam = headers.indexOf("íŒ€ëª…"); const idxQuarter = headers.indexOf("ì¿¼í„°êµ¬ë¶„"); const idxScore = headers.indexOf("ìŠ¤ì½”ì–´");
            if (idxPos === -1) { alert("CSV í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. 'ìœ„ì¹˜' ì»¬ëŸ¼ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
            
            eventList = [];
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(",").map(c => c.trim());
                if (row.length < headers.length) continue;
                const rawTime = parseFloat(row[idxPos]);
                if (isNaN(rawTime)) continue;
                
                const code = row[idxName] || "Event";
                let labels = [];
                if (idxTeam > -1 && row[idxTeam]) labels.push(row[idxTeam]);
                if (idxQuarter > -1 && row[idxQuarter]) labels.push(row[idxQuarter]);
                if (idxScore > -1 && row[idxScore]) labels.push(row[idxScore]);
                eventList.push({ start: rawTime, code: code, label: labels.join(" | ") });
            }
            
            document.getElementById('timeUnit').value = 'cs';
            renderDataList();
        }

        // ë°ì´í„° ê·¸ë£¹í™” ë Œë”ë§
        function renderDataList() {
            const unit = document.getElementById('timeUnit').value;
            const listEl = document.getElementById('dataList'); listEl.innerHTML = '';
            
            if(eventList.length === 0) { listEl.innerHTML = '<div style="color:#777; text-align:center;">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'; return; }
            
            const displayList = eventList.map(evt => {
                let finalStart = evt.start;
                if (unit === 'ms') finalStart = evt.start / 1000;
                else if (unit === 'cs') finalStart = evt.start / 100;
                return { ...evt, displayStart: finalStart };
            });

            displayList.sort((a, b) => a.displayStart - b.displayStart);
            
            const groupedData = {};
            displayList.forEach(evt => {
                const c = evt.code || "Uncategorized";
                if(!groupedData[c]) groupedData[c] = [];
                groupedData[c].push(evt);
            });

            for (const [code, items] of Object.entries(groupedData)) {
                const groupContainer = document.createElement('div');
                groupContainer.className = 'data-group';

                const groupHeader = document.createElement('div');
                groupHeader.className = 'data-group-header';
                groupHeader.innerHTML = `
                    <i class="fa-solid fa-chevron-down group-toggle-icon"></i> 
                    <span>${code}</span> 
                    <span class="group-count">${items.length}</span>
                `;

                const groupContent = document.createElement('div');
                groupContent.className = 'data-group-content';
                
                groupHeader.onclick = () => {
                    const isClosed = groupContent.style.display === 'none';
                    groupContent.style.display = isClosed ? 'flex' : 'none';
                    groupHeader.querySelector('.group-toggle-icon').className = isClosed ? 'fa-solid fa-chevron-down group-toggle-icon' : 'fa-solid fa-chevron-right group-toggle-icon';
                };

                items.forEach((evt) => {
                    const item = document.createElement('div'); 
                    item.className = 'data-item';
                    item.innerHTML = `
                        <div class="scene-info">
                            <span class="data-label">${evt.label || '-'}</span>
                            <span class="scene-time"><i class="fa-regular fa-clock"></i> ${formatTime(evt.displayStart)}</span>
                        </div>
                        <i class="fa-solid fa-play" style="color:#888;"></i>
                    `;
                    item.onclick = () => jumpToTime(evt.displayStart); 
                    groupContent.appendChild(item);
                });

                groupContainer.appendChild(groupHeader);
                groupContainer.appendChild(groupContent);
                listEl.appendChild(groupContainer);
            }
        }

        function jumpToTime(seconds) {
            const targetTime = Math.max(0, seconds + timeOffset);
            if(currentMediaType === 'local' && localVideo.src) { localVideo.currentTime = targetTime; localVideo.play(); }
            else if(currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.seekTo) { ytPlayer.seekTo(targetTime, true); ytPlayer.playVideo(); }
            else { showStatus("ì¬ìƒí•  ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤."); }
        }
        function adjustSync(val) { timeOffset += val; timeOffset = Math.round(timeOffset * 10) / 10; const sign = timeOffset >= 0 ? '+' : ''; document.getElementById('syncDisplay').innerText = `Sync: ${sign}${timeOffset}s`; showStatus(`ì‹±í¬ ì¡°ì ˆ: ${sign}${timeOffset}ì´ˆ`); }
        function openTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            const btns = document.querySelectorAll('.tab-btn');
            if(tabId === 'tab-scenes') btns[0].classList.add('active'); else btns[1].classList.add('active');
        }

        let savedScenes = [];
        function saveScene() {
            const art = JSON.stringify(canvas.toJSON());
            let time = 0; if(currentMediaType === 'local' && localVideo.src) time = localVideo.currentTime; else if(currentMediaType === 'youtube' && isYtReady) time = ytPlayer.getCurrentTime();
            const sceneId = Date.now(); const scene = { id: sceneId, art: art, time: time, type: currentMediaType, label: `Scene ${savedScenes.length + 1}`, isSelected: true };
            savedScenes.push(scene); renderSceneList(); 
            showStatus("í˜„ì¬ ì¥ë©´ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
            
            setTimeout(() => {
                if(confirm("ì¥ë©´ì´ ì•ˆì „í•˜ê²Œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\nìƒˆë¡œìš´ ì¥ë©´ ë¶„ì„ì„ ìœ„í•´ í™”ë©´ì˜ ê·¸ë¦¼ì„ ëª¨ë‘ ì§€ìš¸ê¹Œìš”?")) {
                    const objects = canvas.getObjects();
                    for (let i = objects.length - 1; i >= 0; i--) { canvas.remove(objects[i]); }
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                    resetDrawing();
                    showStatus("í™”ë©´ì´ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.");
                }
            }, 100);
        }

        function loadScene(id) {
            const scene = savedScenes.find(s => s.id === id); if(!scene) return;
            if(scene.type !== currentMediaType && scene.type !== 'image') { if(!confirm("ë¯¸ë””ì–´ ì†ŒìŠ¤ê°€ ë‹¤ë¦…ë‹ˆë‹¤. ì „í™˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return; }
            canvas.loadFromJSON(scene.art, canvas.renderAll.bind(canvas));
            if(scene.type === 'local' && localVideo.src) localVideo.currentTime = scene.time; else if(scene.type === 'youtube' && isYtReady && ytPlayer && ytPlayer.seekTo) ytPlayer.seekTo(scene.time, true);
            showStatus("ì¥ë©´ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
        }
        function removeScene(id, event) { event.stopPropagation(); savedScenes = savedScenes.filter(s => s.id !== id); renderSceneList(); }
        
        function renderSceneList() {
            const listEl = document.getElementById('sceneList'); listEl.innerHTML = '';
            savedScenes.forEach(scene => {
                let timeStr = (scene.type === 'image') ? 'Image' : formatTime(scene.time);
                const item = document.createElement('div'); item.className = 'scene-item';
                item.innerHTML = `
                    <div style="display:flex; align-items:center; gap:10px; width:calc(100% - 25px);">
                        <input type="checkbox" ${scene.isSelected ? 'checked' : ''} onchange="toggleSceneSelection(${scene.id}, event)" style="transform: scale(1.2); cursor: pointer; flex-shrink: 0;" title="ë…¹í™” í¬í•¨">
                        <div class="scene-info" onclick="loadScene(${scene.id})" title="ì¥ë©´ìœ¼ë¡œ ì´ë™">
                            <span class="scene-title">${scene.label}</span>
                            <span class="scene-time"><i class="fa-regular fa-clock"></i> ${timeStr}</span>
                        </div>
                    </div>
                    <button class="scene-del-btn" onclick="removeScene(${scene.id}, event)" title="ì¥ë©´ ì‚­ì œ"><i class="fa-solid fa-xmark"></i></button>
                `;
                listEl.appendChild(item);
            });
        }

        function toggleSceneSelection(id, event) {
            const scene = savedScenes.find(s => s.id === id);
            if (scene) {
                scene.isSelected = event.target.checked;
            }
        }

        function toggleSceneSidebar() {
            const sidebar = document.getElementById('sceneSidebar'); const icon = document.getElementById('sceneToggleIcon');
            sidebar.classList.toggle('closed');
            if(sidebar.classList.contains('closed')) icon.className = 'fa-solid fa-chevron-left'; else icon.className = 'fa-solid fa-chevron-right';
            setTimeout(resizeCanvas, 350); 
        }

        let currentMediaType = 'none'; let ytPlayer; let isYtReady = false;
        const localVideo = document.getElementById('local-video'); const ytDiv = document.getElementById('youtube-player');
        const playBtn = document.getElementById('btn-play'); const scrubberContainer = document.getElementById('videoScrubber');
        const timeSlider = document.getElementById('timeSlider'); const timeDisplay = document.getElementById('timeDisplay');
        let isDraggingSlider = false; let isRecording = false;

        const canvas = new fabric.Canvas('c', { preserveObjectStacking: true });
        canvas.setBackgroundColor(null, canvas.renderAll.bind(canvas));

        function resizeCanvas() {
            const container = document.getElementById('mediaContainer');
            if(container.offsetWidth === 0) return; 
            canvas.setWidth(container.offsetWidth); canvas.setHeight(container.offsetHeight); canvas.renderAll();
        }
        window.addEventListener('resize', resizeCanvas);

        function switchMode(mode) {
            const ytEl = document.getElementById('youtube-player');
            if (currentMediaType === 'youtube' && ytPlayer && isYtReady && ytPlayer.stopVideo) { ytPlayer.stopVideo(); if(ytEl) ytEl.style.display = 'none'; }
            if (currentMediaType === 'local') { localVideo.pause(); localVideo.style.display = 'none'; localVideo.src = ""; }
            
            canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); 
            
            currentMediaType = mode; playBtn.innerHTML = '<i class="fa-solid fa-play"></i>';
            
            if (mode === 'youtube') { if(ytEl) ytEl.style.display = 'block'; scrubberContainer.style.display = 'flex'; }
            else if (mode === 'local') { localVideo.style.display = 'block'; scrubberContainer.style.display = 'flex'; }
            else { scrubberContainer.style.display = 'none'; }
            
            showStatus("", true); resizeCanvas();
        }

        document.getElementById('imgInput').addEventListener('change', function(e) {
            const f = e.target.files[0]; if(!f) return; switchMode('image');
            const r = new FileReader(); r.onload = function(d) { fabric.Image.fromURL(d.target.result, function(img) { if(!img) return; const container = document.getElementById('mediaContainer'); const ratio = Math.min(container.offsetWidth / img.width, container.offsetHeight / img.height); canvas.setWidth(img.width * ratio); canvas.setHeight(img.height * ratio); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: ratio, scaleY: ratio }); }); }; r.readAsDataURL(f); e.target.value = '';
        });
        document.getElementById('videoInput').addEventListener('change', function(e) {
            const f = e.target.files[0]; if(!f) return; switchMode('local'); const url = URL.createObjectURL(f); localVideo.src = url; statusMsg.innerText = "ë¡œì»¬ ë¹„ë””ì˜¤ ëª¨ë“œ"; setTimeout(resizeCanvas, 500);
        });
        
        window.onYouTubeIframeAPIReady = function() { 
            ytPlayer = new YT.Player('youtube-player', { 
                height: '100%', width: '100%', videoId: '', 
                playerVars: { 
                    'playsinline': 1, 
                    'rel': 0,
                    'controls': 1, 
                    'iv_load_policy': 3,
                    'disablekb': 1, 
                    'fs': 0,
                    'showinfo': 0,
                    'modestbranding': 1 
                }, 
                events: { 
                    'onReady': (e) => { isYtReady = true; }, 
                    'onStateChange': onYtStateChange,
                    'onError': (e) => {
                        let msg = "ìœ íŠœë¸Œ ì˜ìƒì„ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                        if(e.data === 101 || e.data === 150) msg += "\n(í•´ë‹¹ ìœ íŠœë¸Œ ì±„ë„ ì£¼ì¸ì´ ì™¸ë¶€ ì‚¬ì´íŠ¸ ì¬ìƒì„ ë§‰ì•„ë‘” ì˜ìƒì…ë‹ˆë‹¤.)";
                        alert(msg);
                    }
                } 
            }); 
        };
        
        function onYtStateChange(e) { 
            e.data == YT.PlayerState.PLAYING ? playBtn.innerHTML = '<i class="fa-solid fa-pause"></i>' : playBtn.innerHTML = '<i class="fa-solid fa-play"></i>'; 
            
            if (e.data === YT.PlayerState.ENDED) {
                ytPlayer.seekTo(ytPlayer.getDuration() - 0.5, true);
                ytPlayer.pauseVideo();
            }
        }
        
        function loadYoutubePrompt() { 
            let url = prompt("ìœ íŠœë¸Œ ì£¼ì†Œ (Shorts ë§í¬ë„ ê°€ëŠ¥):", ""); 
            if (url) { 
                const regExp = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/\s]{11})/i;
                const match = url.match(regExp); 
                const videoId = match ? match[1] : null;

                if (videoId) { 
                    switchMode('youtube'); 
                    if(isYtReady && ytPlayer && ytPlayer.loadVideoById) {
                        ytPlayer.loadVideoById(videoId); 
                    } else {
                        showStatus("ìœ íŠœë¸Œ í”Œë ˆì´ì–´ ì´ˆê¸°í™” ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.", true);
                        let retries = 0;
                        const checkReady = setInterval(() => {
                            if(isYtReady && ytPlayer && ytPlayer.loadVideoById) {
                                clearInterval(checkReady);
                                ytPlayer.loadVideoById(videoId);
                            }
                            retries++;
                            if(retries > 20) { 
                                clearInterval(checkReady); 
                                alert("ìœ íŠœë¸Œ ì‹œìŠ¤í…œ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”."); 
                            }
                        }, 500);
                    }
                } else {
                    alert("ì˜¬ë°”ë¥¸ ìœ íŠœë¸Œ URL ë˜ëŠ” Shorts ë§í¬ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                }
            } 
        }

        function formatTime(seconds) { if(isNaN(seconds)) return "0:00"; const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m}:${s < 10 ? '0'+s : s}`; }
        
        function updateTimelineUI() {
            if (!isDraggingSlider) {
                if (currentMediaType === 'local' && localVideo.duration) {
                    timeSlider.value = (localVideo.currentTime / localVideo.duration) * 100;
                    timeDisplay.innerText = `${formatTime(localVideo.currentTime)} / ${formatTime(localVideo.duration)}`;
                } else if (currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.getDuration) {
                    const dur = ytPlayer.getDuration();
                    const cur = ytPlayer.getCurrentTime();
                    if (dur > 0) {
                        timeSlider.value = (cur / dur) * 100;
                        timeDisplay.innerText = `${formatTime(cur)} / ${formatTime(dur)}`;
                    }
                }
            }
            requestAnimationFrame(updateTimelineUI);
        }
        requestAnimationFrame(updateTimelineUI);

        timeSlider.addEventListener('input', () => { 
            isDraggingSlider = true; 
            const val = timeSlider.value / 100;
            if (currentMediaType === 'local' && localVideo.duration) {
                localVideo.currentTime = val * localVideo.duration;
            } else if (currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.getDuration) {
                const dur = ytPlayer.getDuration();
                if (dur > 0 && ytPlayer.seekTo) ytPlayer.seekTo(val * dur, true);
            }
        });
        timeSlider.addEventListener('change', () => { isDraggingSlider = false; });
        
        localVideo.addEventListener('play', () => playBtn.innerHTML = '<i class="fa-solid fa-pause"></i>'); localVideo.addEventListener('pause', () => playBtn.innerHTML = '<i class="fa-solid fa-play"></i>');
        function videoControl(action) { if (currentMediaType === 'local') { if (!localVideo.src) return; switch(action) { case 'toggle': localVideo.paused ? localVideo.play() : localVideo.pause(); break; case 'rewind': localVideo.currentTime = Math.max(0, localVideo.currentTime - 5); break; case 'forward': localVideo.currentTime = Math.min(localVideo.duration, localVideo.currentTime + 5); break; } } else if (currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.getPlayerState) { switch(action) { case 'toggle': (ytPlayer.getPlayerState() == YT.PlayerState.PLAYING) ? ytPlayer.pauseVideo() : ytPlayer.playVideo(); break; case 'rewind': ytPlayer.seekTo(Math.max(0, ytPlayer.getCurrentTime() - 5), true); break; case 'forward': ytPlayer.seekTo(ytPlayer.getCurrentTime() + 5, true); break; } } }

        // Fabric Init
        const broadcastShadow = new fabric.Shadow({ color: 'rgba(0,0,0,0.8)', blur: 8, offsetX: 2, offsetY: 2 });
        fabric.Object.prototype.set({ transparentCorners: false, cornerColor: '#ffffff', cornerStrokeColor: '#000000', borderColor: '#e74c3c', cornerSize: 10, padding: 5, cornerStyle: 'circle', shadow: broadcastShadow });
        let currentMode='select', currentColor='#ffffff', currentSize=40, currentOpacity=0.2, isDashed=false, isSpotMode=false, isPalmRejection=false;
        let isDrawing=false, startPoint=null, activeObj=null, pointArray=[], activePoints=[], activeLines=[], componentArray=[];
        
        function setMode(mode){
            currentMode=mode; document.querySelectorAll('.sidebar .tool-btn').forEach(b=>b.classList.remove('active'));
            const btn=document.getElementById('btn-'+mode); if(btn) btn.classList.add('active');
            const guide = document.getElementById('guide-msg');
            if(mode === 'drawPolyline' || mode === 'drawPolygon') { guide.style.display = 'block'; guide.innerText = "ë”ë¸”í´ë¦­í•˜ì—¬ ë„í˜• ì™„ì„±"; } else { guide.style.display = 'none'; }
            if(mode==='drawPen'){ canvas.isDrawingMode=true; canvas.freeDrawingBrush=new fabric.PencilBrush(canvas); canvas.freeDrawingBrush.color=currentColor; canvas.freeDrawingBrush.width=currentSize/4; canvas.freeDrawingBrush.shadow=broadcastShadow; canvas.selection=false; } 
            else { canvas.isDrawingMode=false; canvas.selection=(mode==='select'); canvas.defaultCursor=(mode==='select')?'default':'crosshair'; const s=(mode==='select'); canvas.forEachObject(o=>{o.selectable=s;o.evented=s;}); }
            canvas.requestRenderAll(); resetDrawing();
        }

        function togglePalm() { isPalmRejection = !isPalmRejection; const btn = document.getElementById('btn-palm'); if(isPalmRejection) { btn.classList.add('active'); btn.innerHTML = '<i class="fa-solid fa-pen-nib"></i>'; showStatus("âœ‹ íŒœ ë¦¬ì ì…˜ ON"); } else { btn.classList.remove('active'); btn.innerHTML = '<i class="fa-solid fa-hand-pointer"></i>'; showStatus("ğŸ–ï¸ íŒœ ë¦¬ì ì…˜ OFF"); } }
        function getStrokeGradient(color) { return new fabric.Gradient({ type: 'linear', gradientUnits: 'percentage', coords: { x1: 0, y1: 0, x2: 0, y2: 1 }, colorStops: [ { offset: 0, color: hexToMutedRgba(color, 0) }, { offset: 0.5, color: hexToMutedRgba(color, 0.5) }, { offset: 1, color: color } ] }); }
        function getEllipseOffset(point, targetX, targetY, rx, ry) { const dx = targetX - point.left; const dy = targetY - point.top; const angle = Math.atan2(dy, dx); const radiusAtAngle = (rx * ry) / Math.sqrt(Math.pow(ry * Math.cos(angle), 2) + Math.pow(rx * Math.sin(angle), 2)); const offset = radiusAtAngle + 2; return { x: point.left + Math.cos(angle) * offset, y: point.top + Math.sin(angle) * offset }; }

        function createPlayerTag(p) {
            const fs = Math.max(16, currentSize * 0.7);
            const isR = (p.x > canvas.width / 2);
            const dir = isR ? -1 : 1;
            
            const text = new fabric.IText('(NR) PLAYER', {
                fontSize: fs, fill: currentColor, fontFamily: 'S-CoreDream-6Bold',
                originX: isR ? 'right' : 'left', originY: 'bottom', 
                left: 0, top: 4,
                shadow: broadcastShadow
            });
            const uw = text.width + 5; 
            const pathData = [['M', -dir * 18, 28], ['L', 0, 0], ['L', dir * uw, 0]];
            const line = new fabric.Path(pathData, {
                fill: '', stroke: currentColor, strokeWidth: 3, strokeLineCap: 'round', strokeLineJoin: 'round', shadow: broadcastShadow, selectable: false
            });
            const tagGroup = new fabric.Group([line, text], {
                left: p.x, top: p.y, originX: isR ? 'right' : 'left', originY: 'top',
                selectable: true, shadow: broadcastShadow, isPlayerTag: true, side: isR ? 'R' : 'L'
            });
            canvas.add(tagGroup);
            canvas.setActiveObject(tagGroup);
            setMode('select');
        }

        canvas.on('mouse:down', function(o) {
            if (isPalmRejection && o.e && (o.e.pointerType === 'touch' || o.e.touches)) return; 
            if(currentMode==='select'||currentMode==='drawPen'||!o.e)return;
            const p=canvas.getPointer(o.e);
            
            if(currentMode === 'drawPlayerTag') { createPlayerTag(p); return; }

            if((currentMode==='drawPolyline' || currentMode==='drawPolygon') && activePoints.length > 0) { const lastPt = activePoints[activePoints.length - 1]; const dist = Math.sqrt(Math.pow(p.x - lastPt.left, 2) + Math.pow(p.y - lastPt.top, 2)); if(dist < 20) return; }
            if(currentMode==='drawSpot') { canvas.add(new fabric.Ellipse({ left: p.x, top: p.y, rx: currentSize, ry: currentSize * 0.4, fill: hexToMutedRgba(currentColor, currentOpacity), stroke: getStrokeGradient(currentColor), strokeWidth: 4, originX: 'center', originY: 'center', shadow: new fabric.Shadow({ color: currentColor, blur: 20 }) })); }
            else if(currentMode==='drawArrow'||currentMode==='drawCurve'){isDrawing=true;startPoint=p;activeObj=new fabric.Line([p.x,p.y,p.x,p.y],{stroke:currentColor,strokeWidth:2,strokeDashArray:[5,5],opacity:0.5,selectable:false});canvas.add(activeObj);}
            else if(currentMode==='drawPolyline'){
                let n; if(isSpotMode) n=new fabric.Ellipse({ left:p.x, top:p.y, rx:currentSize, ry:currentSize*0.4, fill:hexToMutedRgba(currentColor,currentOpacity), stroke: getStrokeGradient(currentColor), strokeWidth: 3, originX:'center', originY:'center', selectable:false, shadow:new fabric.Shadow({color:currentColor,blur:15}) }); else n=new fabric.Circle({radius:4, fill:currentColor, left:p.x, top:p.y, originX:'center', originY:'center', selectable:false});
                activePoints.push(n); pointArray.push({x:p.x,y:p.y}); componentArray.push(n); canvas.add(n);
                if(pointArray.length>1){ const prevNode = activePoints[activePoints.length-2]; const currNode = activePoints[activePoints.length-1]; let startX = prevNode.left, startY = prevNode.top; let endX = currNode.left, endY = currNode.top; if(isSpotMode) { const startOff = getEllipseOffset(prevNode, endX, endY, currentSize, currentSize*0.4); const endOff = getEllipseOffset(currNode, startX, startY, currentSize, currentSize*0.4); startX = startOff.x; startY = startOff.y; endX = endOff.x; endY = endOff.y; } const line=new fabric.Line([startX, startY, endX, endY],{stroke:currentColor,strokeWidth:3,strokeLineCap:'round',shadow:broadcastShadow,selectable:false,evented:false,strokeDashArray:isDashed?[10,5]:false}); activeLines.push(line); componentArray.push(line); canvas.add(line); canvas.sendToBack(line); }
                document.getElementById('btn-finish').classList.add('show');
            }
            else if(currentMode==='drawPolygon'){const c=new fabric.Circle({radius:4,fill:currentColor,left:p.x,top:p.y,originX:'center',originY:'center',selectable:false});activePoints.push(c);pointArray.push({x:p.x,y:p.y});canvas.add(c);if(pointArray.length>1){const l=new fabric.Line([pointArray[pointArray.length-2].x,pointArray[pointArray.length-2].y,pointArray[pointArray.length-1].x,pointArray[pointArray.length-1].y],{stroke:currentColor,strokeWidth:2,strokeDashArray:[5,5],selectable:false});activeLines.push(l);canvas.add(l);}document.getElementById('btn-finish').classList.add('show');}
        });

        const canvasContainer = document.querySelector('.canvas-wrapper'); if(canvasContainer) { canvasContainer.addEventListener('touchstart', function(e) { if (isPalmRejection) { e.stopPropagation(); e.preventDefault(); } }, { capture: true }); }
        canvas.on('mouse:move', o=>{if(isDrawing&&(currentMode==='drawArrow'||currentMode==='drawCurve')){activeObj.set({x2:canvas.getPointer(o.e).x,y2:canvas.getPointer(o.e).y});canvas.renderAll();}});
        canvas.on('mouse:up', o=>{ if((currentMode==='drawArrow'||currentMode==='drawCurve')&&isDrawing){ isDrawing=false; const end=canvas.getPointer(o.e); canvas.remove(activeObj); if(currentMode==='drawArrow') createArrow(startPoint, end); else { const mid = { x: (startPoint.x + end.x)/2, y: (startPoint.y + end.y)/2 }; const cp = { x: mid.x, y: mid.y - 50 }; const curve = new fabric.CurvedArrow(startPoint, cp, end, { stroke: currentColor, strokeWidth: 4, headSize: currentSize, shadow: broadcastShadow, strokeDashArray: isDashed ? [10, 5] : false, objectCaching: false }); canvas.add(curve); canvas.setActiveObject(curve); } setMode('select'); } });
        
        canvas.on('mouse:dblclick', e=>{ 
            if(e.target && e.target.isPlayerTag) {
                const textObj = e.target.getObjects().find(o => o.type === 'i-text');
                const lineObj = e.target.getObjects().find(o => o.type === 'path');
                const newName = prompt("ì„ ìˆ˜ ì´ë¦„ ì…ë ¥:", textObj.text);
                if (newName) {
                    textObj.set('text', newName);
                    const dir = (e.target.side === 'R') ? -1 : 1;
                    lineObj.set('path', [['M', -dir * 18, 28], ['L', 0, 0], ['L', dir * (textObj.width + 5), 0]]);
                    canvas.renderAll();
                }
                return;
            }
            if(!e.target){ if(pointArray.length>0) { const removeCount = (activePoints.length >= 2) ? 2 : activePoints.length; for(let i=0; i<removeCount; i++) { const pt = activePoints.pop(); if(pt) canvas.remove(pt); componentArray.pop(); pointArray.pop(); } if(activeLines.length > 0) { const ln1 = activeLines.pop(); canvas.remove(ln1); componentArray.pop(); } if(activeLines.length > 0) { const ln2 = activeLines.pop(); canvas.remove(ln2); componentArray.pop(); } completeDrawing(); } return; } 
            if(e.target.type==='i-text'){e.target.enterEditing();e.target.selectAll();} 
            else if(currentMode==='drawPolyline'||currentMode==='drawPolygon')completeDrawing(); 
        });
        
        function clearAll(){
            if(confirm("í™”ë©´ì— ê·¸ë ¤ì§„ ëª¨ë“  ì „ìˆ ì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?\n(â€» ìš°ì¸¡ì— ì €ì¥ëœ ì¥ë©´ì€ ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)")){
                const objects = canvas.getObjects();
                for (let i = objects.length - 1; i >= 0; i--) { canvas.remove(objects[i]); }
                canvas.discardActiveObject();
                canvas.requestRenderAll();
                resetDrawing();
                showStatus("í™”ë©´ì´ ê¹¨ë—í•˜ê²Œ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.");
            }
        }
        function deleteObject() { if(pointArray.length>0||isDrawing){activePoints.forEach(p=>canvas.remove(p));activeLines.forEach(l=>canvas.remove(l));canvas.remove(activeObj);resetDrawing();return;} const a=canvas.getActiveObjects();if(a.length){canvas.discardActiveObject();a.forEach(o=>canvas.remove(o));} }
        function resetDrawing(){pointArray=[];activePoints=[];activeLines=[];componentArray=[];isDrawing=false;document.getElementById('btn-finish').classList.remove('show');}
        function completeDrawing(){ if(pointArray.length<2){deleteObject();return;} if(currentMode==='drawPolyline'){ const groupItems = [...componentArray]; const group = new fabric.Group(groupItems, {selectable:true, shadow:broadcastShadow}); componentArray.forEach(o => canvas.remove(o)); canvas.add(group); canvas.setActiveObject(group); } else if(currentMode==='drawPolygon'){const f=new fabric.Polygon(pointArray,{fill:hexToMutedRgba(currentColor,currentOpacity),stroke:currentColor,strokeWidth:2,objectCaching:false,strokeDashArray:isDashed?[10,5]:false});activePoints.forEach(p=>canvas.remove(p));activeLines.forEach(l=>canvas.remove(l));if(f){canvas.add(f);canvas.setActiveObject(f);}} resetDrawing();setMode('select'); }
        async function downloadImage() { try { const stream = await navigator.mediaDevices.getDisplayMedia({ preferCurrentTab: true, video: { mediaSource: 'tab' } }); const track = stream.getVideoTracks()[0]; const imageCapture = new ImageCapture(track); const bitmap = await imageCapture.grabFrame(); const mediaContainer = document.getElementById('mediaContainer'); const rect = mediaContainer.getBoundingClientRect(); const captureWidth = bitmap.width; const captureHeight = bitmap.height; const windowWidth = window.innerWidth; const windowHeight = window.innerHeight; const scaleX = captureWidth / windowWidth; const scaleY = captureHeight / windowHeight; const cropX = rect.left * scaleX; const cropY = rect.top * scaleY; const cropWidth = rect.width * scaleX; const cropHeight = rect.height * scaleY; const tempCanvas = document.createElement('canvas'); tempCanvas.width = cropWidth; tempCanvas.height = cropHeight; const ctx = tempCanvas.getContext('2d'); ctx.drawImage(bitmap, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight); const link = document.createElement('a'); link.download = 'tactical_analysis_cropped.png'; link.href = tempCanvas.toDataURL('image/png'); link.click(); track.stop(); showStatus("í™”ë©´ ìº¡ì²˜ ì™„ë£Œ!"); } catch (err) { alert("í™”ë©´ ìº¡ì²˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤."); } }

        async function startCleanRecording() {
            const selectedScenes = savedScenes.filter(s => s.isSelected !== false);
            if(selectedScenes.length === 0) return alert("ë…¹í™”í•  ì¥ë©´ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
            if(currentMediaType === 'none' || currentMediaType === 'image') return alert("ì‹œí€€ìŠ¤ ì¶”ì¶œì€ ë¹„ë””ì˜¤(ë¡œì»¬/ìœ íŠœë¸Œ) ëª¨ë“œì—ì„œë§Œ ì§€ì›í•©ë‹ˆë‹¤.");

            const preRollStr = prompt("1. ë¶„ì„ ì§€ì  [ëª‡ ì´ˆ ì „]ë¶€í„° ì˜ìƒì„ ì¬ìƒí• ê¹Œìš”?", "1.5");
            if (preRollStr === null) return;
            const holdTimeStr = prompt("2. ê·¸ë¦¼ì´ ê·¸ë ¤ì§„ [ì •ì§€ í™”ë©´]ì„ ëª‡ ì´ˆ ìœ ì§€í• ê¹Œìš”?", "3.0");
            if (holdTimeStr === null) return;
            const postRollStr = prompt("3. ê·¸ë¦¼ì´ ì‚¬ë¼ì§„ í›„ [ëª‡ ì´ˆ ë”] ì¬ìƒí• ê¹Œìš”?", "1.0");
            if (postRollStr === null) return;

            const preRoll = parseFloat(preRollStr) || 1.5;
            const holdTime = (parseFloat(holdTimeStr) || 3.0) * 1000; 
            const postRoll = parseFloat(postRollStr) || 0;

            const recCanvas = document.createElement('canvas');
            recCanvas.width = canvas.width;
            recCanvas.height = canvas.height;
            const ctx = recCanvas.getContext('2d');

            let screenStream = null;
            let screenVideo = null;

            if (currentMediaType === 'youtube') {
                alert("âš ï¸ ìœ íŠœë¸Œ ì˜ìƒ ì¶”ì¶œ ì•ˆë‚´ âš ï¸\n\në¸Œë¼ìš°ì € ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì¸í•´ í™”ë©´ ìº¡ì²˜ ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\në‹¤ìŒ íŒì—…ì—ì„œ ë°˜ë“œì‹œ [ì´ íƒ­(í˜„ì¬ íƒ­)]ì„ ì„ íƒí•˜ê³  ê³µìœ ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.");
                try {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({ preferCurrentTab: true, video: { displaySurface: 'browser' } });
                    screenVideo = document.createElement('video');
                    screenVideo.srcObject = screenStream;
                    screenVideo.muted = true;
                    screenVideo.play();
                    await new Promise(r => screenVideo.onloadedmetadata = r);
                } catch(e) {
                    return alert("í™”ë©´ ê³µìœ  ê¶Œí•œì´ ê±°ë¶€ë˜ì–´ ìœ íŠœë¸Œ ë…¹í™”ë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤.");
                }
            }

            const stream = recCanvas.captureStream(60);
            let options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 15000000 };
            let ext = 'webm';
            
            if (MediaRecorder.isTypeSupported('video/mp4')) { 
                options = { mimeType: 'video/mp4', videoBitsPerSecond: 15000000 }; 
                ext = 'mp4'; 
            } else if (MediaRecorder.isTypeSupported('video/webm; codecs=h264')) { 
                options = { mimeType: 'video/webm; codecs=h264', videoBitsPerSecond: 15000000 }; 
                ext = 'mp4'; 
            }
            
            const recorder = new MediaRecorder(stream, options);
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: options.mimeType });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                a.download = `Tactical_Analysis_${Date.now()}.${ext}`; a.click();
                if (screenStream) screenStream.getTracks().forEach(t => t.stop());
            };

            let isRecordingLoop = true;
            const mediaContainer = document.getElementById('mediaContainer');

            function renderComposite() {
                if(!isRecordingLoop) return;

                if (currentMediaType === 'youtube' && screenVideo) {
                    const rect = mediaContainer.getBoundingClientRect();
                    const scaleX = screenVideo.videoWidth / window.innerWidth;
                    const scaleY = screenVideo.videoHeight / window.innerHeight;
                    const cropX = rect.left * scaleX;
                    const cropY = rect.top * scaleY;
                    const cropW = rect.width * scaleX;
                    const cropH = rect.height * scaleY;

                    ctx.drawImage(screenVideo, cropX, cropY, cropW, cropH, 0, 0, recCanvas.width, recCanvas.height);
                } else if (currentMediaType === 'local') {
                    if(localVideo.readyState >= 2) {
                        ctx.drawImage(localVideo, 0, 0, recCanvas.width, recCanvas.height);
                    } else {
                        ctx.fillStyle = "black"; ctx.fillRect(0,0, recCanvas.width, recCanvas.height);
                    }
                    ctx.drawImage(canvas.getElement(), 0, 0, recCanvas.width, recCanvas.height);
                }
                
                requestAnimationFrame(renderComposite);
            }

            recorder.start();
            renderComposite();
            showStatus(`ì„ íƒëœ ì¥ë©´ ì˜ìƒ ì¶”ì¶œ ì¤‘... (${ext})`, true);

            const timeline = [...selectedScenes].sort((a,b) => a.time - b.time);
            
            for (let s of timeline) {
                let targetTime = Math.max(0, s.time - preRoll);

                if (currentMediaType === 'local') {
                    localVideo.currentTime = targetTime;
                    await new Promise(res => {
                        const onSeeked = () => { localVideo.removeEventListener('seeked', onSeeked); res(); };
                        if (localVideo.seeking) localVideo.addEventListener('seeked', onSeeked); else res();
                    });
                    canvas.clear(); 
                    localVideo.play();
                    await new Promise(res => {
                        const check = () => {
                            if(localVideo.currentTime >= s.time) { localVideo.pause(); res(); }
                            else requestAnimationFrame(check);
                        }; check();
                    });
                } else if (currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.seekTo) {
                    ytPlayer.seekTo(targetTime, true);
                    canvas.clear();
                    ytPlayer.playVideo();
                    await new Promise(res => {
                        const check = () => {
                            if(ytPlayer.getCurrentTime() >= s.time) { ytPlayer.pauseVideo(); res(); }
                            else requestAnimationFrame(check);
                        }; check();
                    });
                }

                await new Promise(res => {
                    canvas.loadFromJSON(s.art, () => {
                        canvas.renderAll();
                        setTimeout(res, holdTime); 
                    });
                });
                canvas.clear();

                if (postRoll > 0) {
                    if (currentMediaType === 'local') {
                        localVideo.play();
                        const endPostRollTime = localVideo.currentTime + postRoll;
                        await new Promise(res => {
                            const checkPost = () => {
                                if(localVideo.currentTime >= endPostRollTime || localVideo.currentTime >= localVideo.duration) { 
                                    localVideo.pause(); res(); 
                                } else requestAnimationFrame(checkPost);
                            }; checkPost();
                        });
                    } else if (currentMediaType === 'youtube' && isYtReady && ytPlayer && ytPlayer.playVideo) {
                        ytPlayer.playVideo();
                        const endPostRollTime = ytPlayer.getCurrentTime() + postRoll;
                        const duration = ytPlayer.getDuration();
                        await new Promise(res => {
                            const checkPost = () => {
                                if(ytPlayer.getCurrentTime() >= endPostRollTime || ytPlayer.getCurrentTime() >= duration) { 
                                    ytPlayer.pauseVideo(); res(); 
                                } else requestAnimationFrame(checkPost);
                            }; checkPost();
                        });
                    }
                }
            }

            isRecordingLoop = false;
            recorder.stop();
            showStatus("ì˜ìƒ ì¶”ì¶œ ì™„ë£Œ!");
        }

        function hexToMutedRgba(h,a){let r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16), gr=r*0.3+g*0.59+b*0.11; return `rgba(${Math.round(r*0.5+gr*0.5)},${Math.round(g*0.5+gr*0.5)},${Math.round(b*0.5+gr*0.5)},${a})`;}
        function toggleDash(){isDashed=!isDashed;updateDashUI();const a=canvas.getActiveObject();if(a){const v=isDashed?[10,5]:false;if(a.type==='group')a.getObjects().forEach(o=>{if(o.type==='path'||o.type==='line')o.set({strokeDashArray:v})});else if(['curvedArrow','line','path','polygon'].includes(a.type))a.set({strokeDashArray:v});canvas.requestRenderAll();}}
        function updateDashUI(){isDashed?dashBtn.classList.add('active'):dashBtn.classList.remove('active');}
        function toggleNodeMode(){isSpotMode=!isSpotMode;if(isSpotMode){nodeBtn.classList.add('active');nodeBtn.innerHTML='<i class="fa-regular fa-circle"></i>';}else{nodeBtn.classList.remove('active');nodeBtn.innerHTML='<i class="fa-solid fa-circle-nodes"></i>';}}
        function setColor(hex,el){ currentColor=hex; document.querySelectorAll('.color-dot').forEach(d=>d.classList.remove('selected')); if(el)el.classList.add('selected'); if(canvas.isDrawingMode)canvas.freeDrawingBrush.color=hex; const a=canvas.getActiveObject(); if(a){ if(a.type==='group')a.getObjects().forEach(o=>{ if(o.type==='line')o.set({stroke:hex}); if(o.type==='circle')o.set({fill:hex}); if(o.type==='ellipse')o.set({stroke:getStrokeGradient(hex), fill:hexToMutedRgba(hex,currentOpacity)}); if(o.type==='path'||(o.type==='triangle'&&o.angle===90))o.set({stroke:hex,fill:hex}); if(o.type==='i-text')o.set({fill:hex}); }); else if(a.type==='curvedArrow')a.set({stroke:hex}); else if(a.type==='ellipse') a.set({stroke:getStrokeGradient(hex), fill:hexToMutedRgba(hex,currentOpacity), shadow:new fabric.Shadow({color:hex,blur:20})}); else if(a.type==='polygon')a.set({stroke:hex,fill:hexToMutedRgba(hex,currentOpacity)}); else if(a.type==='i-text')a.set({fill:hex}); else if(a.type==='path')a.set({stroke:hex}); canvas.requestRenderAll(); } }
        function setCustomColor(hex, id){ document.getElementById('customColorBtn'+id).style.background=hex; setColor(hex, document.getElementById('customColorBtn'+id)); }
        document.getElementById('sizeSlider').addEventListener('input', e=>{currentSize=parseInt(e.target.value);if(canvas.isDrawingMode)canvas.freeDrawingBrush.width=currentSize/4;const a=canvas.getActiveObject();if(a){if(a.type==='ellipse')a.set({rx:currentSize,ry:currentSize*0.4});else if(a.type==='group'){a.getObjects().forEach(o=>{if(o.type==='ellipse')o.set({rx:currentSize,ry:currentSize*0.4})});if(a.getObjects().some(o=>o.type==='triangle'))a.scale(currentSize/40);}else if(a.type==='curvedArrow')a.set({headSize:currentSize});else if(a.type==='i-text')a.set({fontSize:currentSize});else if(a.type==='path')a.set({strokeWidth:currentSize/4});canvas.requestRenderAll();}});
        document.getElementById('opacitySlider').addEventListener('input', e=>{currentOpacity=parseInt(e.target.value)/100;const a=canvas.getActiveObject();if(a){if(a.type==='ellipse'||a.type==='polygon')a.set({fill:hexToMutedRgba(currentColor,currentOpacity)});if(a.type==='group')a.getObjects().forEach(o=>{if(o.type==='ellipse')o.set({fill:hexToMutedRgba(currentColor,currentOpacity)})});canvas.requestRenderAll();}});
        function addText(){const t=new fabric.IText('Text',{left:canvas.width/2,top:canvas.height/2,fontFamily:'S-CoreDream-6Bold',fill:currentColor,fontSize:currentSize,originX:'center',originY:'center',shadow:broadcastShadow,editable:true});canvas.add(t);canvas.setActiveObject(t);t.enterEditing();t.selectAll();setMode('select');}
        function createArrow(s,e){const h=currentSize,a=Math.atan2(e.y-s.y,e.x-s.x)*180/Math.PI,l=Math.sqrt(Math.pow(e.x-s.x,2)+Math.pow(e.y-s.y,2)),mx=(s.x+e.x)/2,my=(s.y+e.y)/2,p=`M ${-l/2} 0 L ${l/2-h+5} 0`,ln=new fabric.Path(p,{stroke:currentColor,strokeWidth:4,strokeDashArray:isDashed?[10,5]:false,fill:'',originX:'center',originY:'center'}),hd=new fabric.Triangle({width:h,height:h,fill:currentColor,angle:90,left:l/2,top:0,originX:'center',originY:'center'}),g=new fabric.Group([ln,hd],{left:mx,top:my,angle:a,originX:'center',originY:'center',shadow:broadcastShadow});canvas.add(g);}
        
        fabric.CurvedArrow = fabric.util.createClass(fabric.Object, { type: 'curvedArrow', initialize: function(p0, p1, p2, options) { this.p0 = p0; this.p1 = p1; this.p2 = p2; options = options || {}; this.callSuper('initialize', options); this.headSize = options.headSize || 30; this.strokeWidth = options.strokeWidth || 5; this.stroke = options.stroke || '#fff'; this.strokeDashArray = options.strokeDashArray || false; this._updateBoundingBox(); this.prevLeft = this.left; this.prevTop = this.top; this.on('moving', () => { const dx = this.left - this.prevLeft; const dy = this.top - this.prevTop; this.p0.x += dx; this.p0.y += dy; this.p1.x += dx; this.p1.y += dy; this.p2.x += dx; this.p2.y += dy; this.prevLeft = this.left; this.prevTop = this.top; }); this.on('selected', () => { this.prevLeft = this.left; this.prevTop = this.top; }); }, _updateBoundingBox: function() { const minX = Math.min(this.p0.x, this.p1.x, this.p2.x); const maxX = Math.max(this.p0.x, this.p1.x, this.p2.x); const minY = Math.min(this.p0.y, this.p1.y, this.p2.y); const maxY = Math.max(this.p0.y, this.p1.y, this.p2.y); this.left = minX; this.top = minY; this.width = maxX - minX; this.height = maxY - minY; }, _render: function(ctx) { ctx.save(); ctx.beginPath(); ctx.lineWidth = this.strokeWidth; ctx.strokeStyle = this.stroke; ctx.lineCap = 'round'; if (this.strokeDashArray) ctx.setLineDash(this.strokeDashArray); const p0 = this.toLocalPoint(new fabric.Point(this.p0.x, this.p0.y), 'center', 'center'); const p1 = this.toLocalPoint(new fabric.Point(this.p1.x, this.p1.y), 'center', 'center'); const p2 = this.toLocalPoint(new fabric.Point(this.p2.x, this.p2.y), 'center', 'center'); ctx.moveTo(p0.x, p0.y); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); ctx.stroke(); ctx.setLineDash([]); let dx = p2.x - p1.x; let dy = p2.y - p1.y; if(dx===0 && dy===0) { dx = p1.x - p0.x; dy = p1.y - p0.y; } const angle = Math.atan2(dy, dx); ctx.translate(p2.x, p2.y); ctx.rotate(angle); ctx.beginPath(); const s = this.headSize; ctx.moveTo(0, 0); ctx.lineTo(-s, s/2); ctx.lineTo(-s, -s/2); ctx.closePath(); ctx.fillStyle = this.stroke; ctx.fill(); ctx.restore(); } });
        fabric.CurvedArrow.prototype.controls = {};
        function createControl(key, color) { return new fabric.Control({ position: { x: 0, y: 0 }, actionName: key, cursorStyle: 'pointer', actionHandler: function(eventData, transform, x, y) { const target = transform.target; target[key] = { x: x, y: y }; target._updateBoundingBox(); target.prevLeft = target.left; target.prevTop = target.top; return true; }, positionHandler: function(dim, finalMatrix, fabricObject) { const point = fabricObject[key]; return fabric.util.transformPoint(new fabric.Point(point.x, point.y), canvas.viewportTransform); }, render: function(ctx, left, top, styleOverride, fabricObject) { ctx.save(); ctx.translate(left, top); ctx.beginPath(); ctx.arc(0, 0, 6, 0, 2 * Math.PI); ctx.fillStyle = color; ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.fill(); ctx.stroke(); ctx.restore(); } }); }
        fabric.CurvedArrow.prototype.controls.p0 = createControl('p0', '#ffffff'); fabric.CurvedArrow.prototype.controls.p1 = createControl('p1', '#3498db'); fabric.CurvedArrow.prototype.controls.p2 = createControl('p2', '#ffffff');

        function toggleLang(){
            const langText = document.getElementById('langText');
            langText.innerText = (langText.innerText === "KR | EN") ? "EN | KR" : "KR | EN";
        }
        function toggleHelp(){const m=document.getElementById('helpModal'); m.style.display=(m.style.display==='flex')?'none':'flex';}
    </script>
</body>
</html>